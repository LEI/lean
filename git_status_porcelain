#!/bin/sh

git_status_porcelain() {
  # --git-dir --is-inside-git-dir --is-bare-repository
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    return $?
  fi
  # branch format/prefix="${1:-on %s%s}"
  dirty_format="${1:-%s}" # dirty repository format
  stage_format="${2:-%s}" # staged, unstaged, unmerged...?
  clean_format="${3:-%s}" # clean repository format

  tmpdir=$(mktemp -d -t git.status)
  tmpfile="$tmpdir/porcelain.fifo"
  mkfifo "$tmpfile" # TODO mktmp to avoid collision?
  git status --porcelain=v2 --ignore-submodules --branch \
    >"$tmpfile" &
  # --untracked-files[=<mode>] (no, normal, default: all)
  # --ignore-submodules[=<when>] (none, untracked, dirty, default: all)

  staged_modified=0
  staged_added=0
  staged_deleted=0
  staged_renamed=0
  staged_copied=0

  unstaged_modified=0
  unstaged_added=0
  unstaged_deleted=0
  unstaged_renamed=0
  unstaged_copied=0

  unmerged=0
  untracked=0
  ignored=0

  while read -r line; do
    case "$line" in
      # https://git-scm.com/docs/git-status#_branch_headers
      "# branch.oid "*) oid="${line#\# branch.oid }" ;; # Current commit (or initial)
      "# branch.head "*) head="${line#\# branch.head }" ;; # Current branch (or detached)
      "# branch.upstream "*) upstream="${line#\# branch.upstream }" ;; # If upstream is set
      "# branch.ab "*) ab="${line#\# branch.ab }" ;; # If upstream is set and the commit is present
      # https://git-scm.com/docs/git-status#_changed_tracked_entries
      # Ordinary changed entries have the following format:
      # 1 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <path>
      # Renamed or copied entries have the following format:
      # 2 <XY> <sub> <mH> <mI> <mW> <hH> <hI> <X><score> <path><sep><origPath>
      1* | 2*) # 1: tracked, 2: renamed
        line="${line#* }"
        xy="${line%% *}"
        case "$(echo "$xy" | cut -c1)" in
          M) staged_modified=$((staged_modified + 1)) ;;
          A) staged_added=$((staged_added + 1)) ;;
          D) staged_deleted=$((staged_deleted + 1)) ;;
          R) staged_renamed=$((staged_renamed + 1)) ;;
          C) staged_copied=$((staged_copied + 1)) ;;
        esac
        case "$(echo "$xy" | cut -c2)" in
          M) unstaged_modified=$((unstaged_modified + 1)) ;;
          A) unstaged_added=$((unstaged_added + 1)) ;;
          D) unstaged_deleted=$((unstaged_deleted + 1)) ;;
          R) unstaged_renamed=$((unstaged_renamed + 1)) ;;
          C) unstaged_copied=$((unstaged_copied + 1)) ;;
        esac
        ;;
      # Unmerged entries have the following format:
      # u <xy> <sub> <m1> <m2> <m3> <mW> <h1> <h2> <h3> <path>
      "u "*) unmerged=$((unmerged + 1)) ;;
      # Untracked items have the following format: ? <path>
      "? "*) untracked=$((untracked + 1)) ;;
      # Ignored items have the following format: ! <path>
      "! "*) ignored=$((ignored + 1)) ;;
      *) # echo >&2 "$line: invalid git status line"
        return 1
        ;;
    esac
  done <"$tmpfile"
  rm "$tmpfile" && rmdir "$tmpdir" # rm -R "$tmpdir"

  branch="${head:-$(echo "$oid" | cut -c-7)}"
  if [ "${GIT_STATUS_UPSTREAM:-0}" -eq 1 ] && [ -n "$upstream" ]; then
    branch="$branch...$upstream"
  fi

  # branch.ab +<ahead> -<behind>
  ahead=0
  behind=0
  if [ -n "$ab" ]; then
    ahead="${ab% -*}"
    ahead="${ahead#+}"
    behind="${ab#+* }"
    behind="${behind#-}"
  fi
  flags=
  [ "$behind" -gt 0 ] && flags="$flags<"
  [ "$ahead" -gt 0 ] && flags="$flags>"

  count=$((count + staged_modified + staged_added + staged_deleted + staged_renamed + staged_copied))
  count=$((count + unstaged_modified + unstaged_added + unstaged_deleted + unstaged_renamed + unstaged_copied))
  count=$((count + unmerged + untracked)) # + ignored

  if [ "$untracked" -gt 0 ]; then
    flags="$flags?$untracked"
  fi
  if [ "$ignored" -gt 0 ]; then
    flags="$flags?$ignored"
  fi

  if [ "$count" -gt 0 ]; then
    # flags="$flags*"
    branch_format="$dirty_format"
  elif [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
    branch_format="$stage_format"
  else
    branch_format="$clean_format"
  fi
  # shellcheck disable=SC2059
  branch="$(printf "$branch_format" "$branch")"

  printf "%s%s" "$branch" "$flags"

  ret=0
  [ "$count" -gt 0 ] && ret="${GIT_STATUS_staged_RET:-2}"
  return "$ret"
}

# git_status_porcelain "$@"
